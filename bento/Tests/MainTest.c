/* (use tabs = 2 to view this file correctly) */
/*---------------------------------------------------------------------------*
 |                                                                           |
 |                            <<< MainTest.c  >>>                            |
 |                                                                           |
 |                  Container Manager Testing (Brute Force!)                 |
 |                                                                           |
 |                               Ira L. Ruben                                |
 |                                 12/30/91                                  |
 |                                                                           |
 |                  Copyright Apple Computer, Inc. 1991-1992                 |
 |                           All rights reserved.                            |
 |                                                                           |
 *---------------------------------------------------------------------------*
 
 This is a "little" test file used to drive the API and "rattle its chain" in various ways
 to debug it. It use the ExampleHandler for its I/O.  See routine processOptions() for 
 the options you can use for this test.
 
 The test program is not "polished" like the CM code (if you can describe it like that).
 This progam was mainly generated by the author to directly test the stuff as it was being
 developed.  As such the test built up linearly, one after another.  Hence the size of
 main (and only) test.  It has been embellished only to the point that it can now be used
 as a regression test.
 
 It currently does NOT test every API routine.  Only the most critical.  If someone else
 cares they can add to this program.  I am satisfied just by looking at the code that the
 untested stuff is correct (a better explaination is I am tired of working on this thing).
 
 Unlike the ExampleHandler and source code, this file has no comments.  I've run out of
 words!
*/

/*#include <types.h>*/
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

/* The following is for testing under Think C. It allows us to generate a Unix or MPW		*/
/* command line argv vector. CAUTION about using Think C -- The standard I/O only works	*/
/* if you use 2-byte integers. 																													*/

#ifndef THINK_C
#define THINK_C 0
#endif
#ifndef THINK_CPLUS
#define THINK_CPLUS 0
#endif

#if THINK_C || THINK_CPLUS
#include <console.h>
#endif

#include "CMAPI.h" 
#include "CMAPIDbg.h"    							/* assume the debugging support is there!					*/
#include "XHandlrs.h"       
#include "XEmbeded.h"               
#include "XSession.h"              
																	
																	CM_CFUNCTIONS

#ifndef __TYPES__
enum {false,true};
typedef unsigned char Boolean;
#endif

CMSession			 	session;
static FILE 		*dbgFile = NULL;
static FILE			*handlerDbgFile = NULL;
static FILE			*rawDataFile;
static int 			failures = 0, successes = 0;
static char 		whatWeGot[256], origFilename[256], filename[256] = {0};
static Boolean 	traceHandlers 	= false,
								fullEmbedClose 	= false,
								dbgEmbedded 		= false,
								embedTestOnly 	= false,
								basicTestOnly 	= false,
								refsTestOnly		= false,
								convTestOnly 		= false,
								dontClose 			= false,
								reuseSpace			= true,
								showSize				= false,
								quiet 					= true;


/* The following is a cheap and dirty way to register type names used in the various		*/
/* tests.  Each group of tests placed into a single property must be unique.  An 				*/
/* alternate scheme would be to use the same type by different properties.  Due to the	*/
/* historical (or hysterical) way the API evolved, changing the types is more 					*/
/* convenient.																																					*/

#define TestType(t) (CMRegisterType(container, (CMGlobalName)t))


/*------------------------------*
 | display - isolate all output |
 *------------------------------*
 
 In some environments it may be more desirable (or necessary) to handle I/O specially. To
 that end this routine is provided.  There is no input in this test (other than the
 command line -- if you got one).  So only output needs to be handled. It all goes through
 here.  It's parameters are identical to fprintf(), with the same meaning.  So, as
 delivered, in its simplest form, this routine maps into a fprintf().  Feel free to "warp"
 this routine into somthing appropriate to your system.
*/

static void CM_NEAR CM_C display(FILE *stream, const char *format, ...)
{
	va_list ap;
	
	va_start(ap, format);
	vfprintf(stream, format, ap);
	va_end(ap);
}


/*----------------*
 | processOptions |
 *----------------*/

static void CM_NEAR processOptions(int argc, char *argv[])
{
	int  i;
	char c, *arg;
	FILE *f;
	
	#define CmdLineOptionSyntax "[containerFile] [-t stderr|stdout] [-p] [-r] [-x stderr|stdout] [-k] [-b] [-c] [-n] [-s] [-e] [-R] [-z]"
	
	for (i = 1; i < argc; ++i) {
		arg = argv[i];
		if (*arg == '-') 
			switch (c = *++arg) {
				case '?':
				case 'h':	display(stderr, "\n%s %s\n\n"
																	"   containerFile     Name of container file.  If omitted, the file\n"
																	"                     \"TestC\" is used.\n\n", argv[0], CmdLineOptionSyntax);
									display(stderr, "   -b                Do basic tests only.\n\n");
									display(stderr, "   -c                Do converting tests only.\n\n");
									display(stderr, "   -e                Do embedding tests only.\n\n");
									display(stderr, "   -R                Do reference tests only (case sensitive option -- sorry).\n\n");
									display(stderr, "   -n                Do NOT reuse space in basic tests.\n\n");
									display(stderr, "   -s                Show container size of basic tests container.\n\n");
									display(stderr, "   -k                Do single close of parent of all embedded containers\n"
																	"                     in the embedded container creation test.  The default\n"
																	"                     is to close them individually in the proper order.\n\n");
									display(stderr, "   -p                Display test output to stderr.  The defualt is to run\n"
																	"                     quietly and self-check the results.  A summary is given\n"
																	"                     at the end of the program.\n\n");
									display(stderr, "   -r                The default is to treat each test separately so that the\n"
																	"                     container written to is closed and then reopened for\n"
																	"                     reading it.  This option suppresses that. The container\n"
																	"                     is opened, written, read, and then closed with -r.\n\n");
									display(stderr, "   -t stderr|stdout  Send handler debugging output and input TOC display\n"
																	"                     to the specified file.  If omitted, no debugging\n"
																	"                     output is generated.\n\n");
									display(stderr, "   -x stderr|stdout  Trace handlers to the specified file.\n\n");
									display(stderr, "   -z                Show some info for debugging embedded containers.\n");
																												 
									exit(EXIT_SUCCESS);
				
				case 'b':	basicTestOnly = true;
									break;
				
				case 'n':	reuseSpace = false;
									break;
				
				case 's':	showSize = true;
									break;
									
				case 'c':	convTestOnly = true;
									break;
			
				case 'e':	embedTestOnly = true;
									break;
				
				case 'k': fullEmbedClose = true;
									break;
				
				case 'p':	quiet = false;
									break;
									
				case 'R': refsTestOnly = true;
									break;

				case 'r': dontClose = true;
									break;
				
				case 't':
				case 'x':	if ((arg = argv[++i]) != NULL)
										if (strcmp(arg, "stderr") == 0)
											f = stderr;
										else if (strcmp(arg, "stdout") == 0)
											f = stdout;
										else
											arg = NULL;
									if (arg == NULL) {
										display(stderr, "### Usage: %s %s\n"
																	  "###        Should have -t stdout | stderr on -%c\n", argv[0], CmdLineOptionSyntax, c);
										exit(EXIT_SUCCESS);
									}
									if (c == 'x') {
										traceHandlers = true;
										handlerDbgFile = f;
									} else
										dbgFile = f;
									break; 
									
				case 'z': dbgEmbedded = true;
									break;
				
				default:	display(stderr, "### Usage: %s %s\n"
																	"###        Invalid option: \"%s\"\n", argv[0], CmdLineOptionSyntax, arg-1);
									exit(EXIT_FAILURE);
			}
		else if (*filename == 0)
			strcpy(filename, arg);
		else {
			display(stderr, "### Usage: %s %s\n"
											"###        More than one filename specified\n", argv[0], CmdLineOptionSyntax);
			exit(EXIT_FAILURE);
		}
	}
}


/*---------*
 | checkIt |
 *---------*/

static void CM_NEAR checkIt(char *whatWeGot, char *whatItShouldBe)
{
	if (strcmp(whatWeGot, whatItShouldBe) != 0) {
		display(stderr, "### test failed! Expected \"%s\"\n"
										"                 Got      \"%s\"\n", whatItShouldBe, whatWeGot);
		++failures;
	} else {
		++successes;
		if (!quiet) display(stderr, "%s\n", whatWeGot);
	}
}


/*--------------*
 | doBasicTests |
 *--------------*/

static void CM_NEAR doBasicTests(CMBoolean fullTest, char *filename)
{
	CMContainer 	 container;
	CMRefCon			 myRefCon;
	CMType				 t0, t1, t2, t3;
	CMProperty		 p0, p1, p2, p3, p5, p6, p7a, p7b;
	CMObject			 o0, o1, o3, o4, o5, o6;
	CMValue				 v0, v1, v2, v3, v4, v5, v6, v7, v8, v9a, v9b, v10a, v10b, v11, v12, v13,
								 v17a, v17b, v18, v19a, v19b, v20a, v20b, v21a, v21b, v22a, v22b, v22c,
								 v22d, v23, v24, v25a, v25b, v26;
	CMHandlerAddr	 theHandler;
	CMSize				 amountRead, expectedSize, tocSize, containerSize;
	unsigned char  buffer[256];
	
	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);

	if (!quiet && fullTest) 
		display(stderr, "\nContainer we are using is: \"%s\"\n\n", filename);
	
	if (!quiet && fullTest) 
		display(stderr, "Write tests to test CMWriteValueData() in all contortions...\n");
	
	CMSetMetaHandler(session, "Debugging1", containerMetahandler);
	container = CMOpenNewContainer(session, myRefCon, "Debugging1",
																 (CMContainerUseMode)(reuseSpace ? kCMReuseFreeSpace : 0),
																 1, 0);
																 
	expectedSize = reuseSpace ? 0x6F4 : 0x6F4;
	
	if (container == NULL) {
		display(stderr, "### writing tests terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	o1 = CMNewObject(container);						/* define here to create forward references		*/
	
	p1 = CMRegisterProperty(container, "property #1");
	p2 = CMRegisterProperty(container, "property #2");
	p3 = CMRegisterProperty(container, "value tests");
	p5 = CMRegisterProperty(container, "insert tests");
	p6 = CMRegisterProperty(container, "delete tests");
	p7a= CMRegisterProperty(container, "move tests (from)");
	p7b= CMRegisterProperty(container, "move tests (to)");
	
	t1 = CMRegisterType(container, "type #1");
	t2 = CMRegisterType(container, "type #2");
	
	
	/*--------------------------*
	 | CMWriteValueData() tests |
	 *--------------------------*/

	/*o1 = CMNewObject(container);*/					/* test 1: immediate data	*/
	v1 = CMNewValue(o1, p3, TestType("t1"));
	CMSetValueType(v1, t1);										/* through in this test in as well */
	CMSetValueGeneration(v1, 2);
	CMWriteValueData(v1, (CMPtr)"123", 0, 3);
	
	v2 = CMNewValue(o1, p3, TestType("t2"));	/* test 2: nonimmediate data */
	CMWriteValueData(v2, (CMPtr)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 26);
	
	v3 = CMNewValue(o1, p3, TestType("t3"));	/* test 3: pure overwrite of immediate */
	CMWriteValueData(v3, (CMPtr)"ABC", 0, 3);
	CMWriteValueData(v3, (CMPtr)"xy", 2, 2);
	
	v4 = CMNewValue(o1, p3, TestType("t4"));	/* test 4: pure overwrite of nonimmediate */
	CMWriteValueData(v4, (CMPtr)"123456789012345678901234567890", 0, 30);
	CMWriteValueData(v4, (CMPtr)"ABCDEFGHIJ", 10, 10);
	
	v5 = CMNewValue(o1, p3, TestType("t5"));	/* test 5: concat to immediate */
	CMWriteValueData(v5, (CMPtr)"ab", 0, 2);
	CMWriteValueData(v5, (CMPtr)"CD", 2, 2);
	
	v6 = CMNewValue(o1, p3, TestType("t6"));	/* test 6: concat to non-immediate */
	CMWriteValueData(v6, (CMPtr)"1234567890", 0, 10);
	CMWriteValueData(v6, (CMPtr)"ABCDE", 10, 5);
	
	v7 = CMNewValue(o1, p3, TestType("t7"));	/* test 7: extend immediate to nonimmediate */
	CMWriteValueData(v7, (CMPtr)"1234", 0, 4);
	CMWriteValueData(v7, (CMPtr)"ABCDE", 3, 5);

	v8 = CMNewValue(o1, p3, TestType("t8"));	/* test 8: extend nonimmediate */
	CMWriteValueData(v8, (CMPtr)"1234567890", 0, 10);
	CMWriteValueData(v8, (CMPtr)"****Test8****", 2, 13);
	
	v9a = CMNewValue(o1, p3, TestType("t9a"));/* test 9: continued value */
	v9b = CMNewValue(o1, p3, TestType("t9b"));
	CMWriteValueData(v9a, (CMPtr)"1234567890", 0, 10);
		CMWriteValueData(v9b, (CMPtr)"abcdefghij", 0, 10);
	CMWriteValueData(v9a, (CMPtr)"ABCDEFGHIJ", 10, 10);
		CMWriteValueData(v9b, (CMPtr)"1234567890", 10, 10);
	CMWriteValueData(v9a, (CMPtr)"abcdefghij", 20, 10);
		CMWriteValueData(v9b, (CMPtr)"ABCDEFGHIJ", 20, 10);
	
	v10a = CMNewValue(o1, p3, TestType("t10a"));/* test 10: overwrite of continued value */
	v10b = CMNewValue(o1, p3, TestType("t10b"));
	CMWriteValueData(v10a, (CMPtr)"ABCDE", 0, 5);
	  CMWriteValueData(v10b, (CMPtr)"abcde", 0, 5);
	CMWriteValueData(v10a, (CMPtr)"FGHIJ", 5, 5);
	  CMWriteValueData(v10b, (CMPtr)"fghij", 5, 5);
	CMWriteValueData(v10a, (CMPtr)"KLMNO", 10, 5);
	  CMWriteValueData(v10b, (CMPtr)"klmno", 10, 5);
	CMWriteValueData(v10a, (CMPtr)"PQRST", 15, 5);
	  CMWriteValueData(v10b, (CMPtr)"pqrst", 15, 5);
	
	CMWriteValueData(v10a, (CMPtr)"###TEST10###", 7, 12);
	CMWriteValueData(v10b, (CMPtr)"***test10***", 13, 12);
	
	v11 = CMNewValue(o1, p3, TestType("t11"));/* test 11: (over)write of data with size 0 */
	CMWriteValueData(v11, (CMPtr)"Size=0", 0, 0);
	CMWriteValueData(v11, (CMPtr)"12345", 0, 0); 
	
	v12 = CMNewValue(o1, p3, TestType("t12"));				
	CMWriteValueData(v12, (CMPtr)"test", 0, 4);
	CMWriteValueData(v12, (CMPtr)"12345", 2, 0); 

	v13 = CMNewValue(o1, p3, TestType("t13"));
	CMWriteValueData(v13, (CMPtr)"Ira Ruben", 0, 9);
	CMWriteValueData(v13, (CMPtr)"12345", 2, 0);
	
	
	/*---------------------------*
	 | CMInsertValueData() Tests |
	 *---------------------------*/
	
	o3 = CMNewObject(container);
	
	v17a = CMNewValue(o3, p5, TestType("t17a"));
	CMWriteValueData(v17a, (CMPtr)"wz", 0, 2);
	v17b = CMNewValue(o3, p5, TestType("t17b"));
	CMWriteValueData(v17b, (CMPtr)"ABGH", 0, 4);
	
	v18 = CMNewValue(o3, p5, TestType("t18"));
	CMWriteValueData(v18, (CMPtr)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 26);
	
	v19a = CMNewValue(o3, p5, TestType("t19a"));
	v19b = CMNewValue(o3, p5, TestType("t19b"));
	CMWriteValueData(v19a, (CMPtr)"1234567890", 0, 10);
		CMWriteValueData(v19b, (CMPtr)"abcdefghij", 0, 10);
	CMWriteValueData(v19a, (CMPtr)"ABCDEFGHIJ", 10, 10);
		CMWriteValueData(v19b, (CMPtr)"1234567890", 10, 10);
	CMWriteValueData(v19a, (CMPtr)"abcdefghij", 20, 10);
		CMWriteValueData(v19b, (CMPtr)"ABCDEFGHIJ", 20, 10);

	CMInsertValueData(v17a, (CMPtr)"xy", 1, 2);					/* test 1: small insert into small immediate */
	CMInsertValueData(v17b, (CMPtr)"CDEF", 2, 4);				/* test 2: large insert into large immediate */
	CMInsertValueData(v18,  (CMPtr)"1234567890", 9, 10);/* test 3: insert into non-immediate */
	CMInsertValueData(v19a, (CMPtr)"<insert>", 15, 8);	/* test 4: insert into middle of cont'd seg */
	CMInsertValueData(v19b, (CMPtr)"<insert>", 20, 8);	/* test 5: insert into start of cont'd seg */


	/*---------------------------*
	 | CMDeleteValueData() Tests |
	 *---------------------------*/

	o4 = CMNewObject(container);
	
	v20a = CMNewValue(o4, p6, TestType("t20a"));
	CMWriteValueData(v20a, (CMPtr)"ABCD", 0, 4);
	v20b = CMNewValue(o4, p6, TestType("t20b"));
	CMWriteValueData(v20b, (CMPtr)"abcd", 0, 4);
	
	v21a = CMNewValue(o4, p6, TestType("t21a"));
	CMWriteValueData(v21a, (CMPtr)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 26);
	v21b = CMNewValue(o4, p6, TestType("t21b"));
	CMWriteValueData(v21b, (CMPtr)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 26);
	
	v22a = CMNewValue(o4, p6, TestType("t22a"));
	v22b = CMNewValue(o4, p6, TestType("t22b"));
	v22c = CMNewValue(o4, p6, TestType("t22c"));
	v22d = CMNewValue(o4, p6, TestType("t22d"));
	CMWriteValueData(v22a, (CMPtr)"1234567890", 0, 10);
		CMWriteValueData(v22b, (CMPtr)"abcdefghij", 0, 10);
			CMWriteValueData(v22c, (CMPtr)"1234567890", 0, 10);
				CMWriteValueData(v22d, (CMPtr)"1234567890", 0, 10);
	CMWriteValueData(v22a, (CMPtr)"ABCDEFGHIJ", 10, 10);
		CMWriteValueData(v22b, (CMPtr)"1234567890", 10, 10);
			CMWriteValueData(v22c, (CMPtr)"ABCDEFGHIJ", 10, 10);
				CMWriteValueData(v22d, (CMPtr)"ABCDEFGHIJ", 10, 10);
	CMWriteValueData(v22a, (CMPtr)"abcdefghij", 20, 10);
		CMWriteValueData(v22b, (CMPtr)"ABCDEFGHIJ", 20, 10);
			CMWriteValueData(v22c, (CMPtr)"abcdefghij", 20, 10);
				CMWriteValueData(v22d, (CMPtr)"abcdefghij", 20, 10);

	CMDeleteValueData(v20a, 1, 2);									/* test 1: delete of immediate */
	CMDeleteValueData(v20b, 0, 4);									/* test 2: delete of entire immediate */
	CMDeleteValueData(v21a, 10, 9);									/* test 3: delete of non-immediate */
	CMDeleteValueData(v21b, 0, 100);								/* test 4: delete of entire non-immediate */
	CMDeleteValueData(v22a, 5, 19);									/* test 5: delete of cont'd */
	CMDeleteValueData(v22b, 23, 4);									/* test 6: delete of cont'd - part of last seg */
	CMDeleteValueData(v22c, 5, 100);								/* test 6: delete of cont'd - seg to end */
	CMDeleteValueData(v22d, 15, 100);								/* test 7: delete of cont'd - middle seg to end */


	v26 = CMNewValue(o4, p6, TestType("t26"));
	CMWriteValueData(v26, (CMPtr)"1234567890", 0, 10);
	CMDeleteValueData(v26, 0, 100);									/* test 8: delete of entire value data */
	CMInsertValueData(v26, (CMPtr)"<insert>", 0, 8);/*				 followed by inserted replace*/
	

	/*---------------------*
	 | CMMoveValue() Tests |
	 *---------------------*/
	
	o5 = CMNewObject(container);

	v23 = CMNewValue(o5, p7a, TestType("t23"));			/* immediate value */
	CMWriteValueData(v23, (CMPtr)"dcba", 0, 4);						
	
	v24 = CMNewValue(o5, p7a, TestType("t24"));			/* non-immediate value */
	CMWriteValueData(v24, (CMPtr)"ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 26);

	v25a = CMNewValue(o5, p7a, TestType("t25a"));		/* continued value */
	v25b = CMNewValue(o5, p7a, TestType("t25b"));
	CMWriteValueData(v25a, (CMPtr)"1234567890", 0, 10);
		CMWriteValueData(v25b, (CMPtr)"abcdefghij", 0, 10);
	CMWriteValueData(v25a, (CMPtr)"ABCDEFGHIJ", 10, 10);
		CMWriteValueData(v25b, (CMPtr)"1234567890", 10, 10);
	CMWriteValueData(v25a, (CMPtr)"abcdefghij", 20, 10);
		CMWriteValueData(v25b, (CMPtr)"ABCDEFGHIJ", 20, 10);
	
	o6 = CMNewObject(container);						
	CMMoveValue(v23, o6, p7b);											/* test 1: move of immediate */
	CMMoveValue(v24, o6, p7b);											/* test 2: move or non-immediate */
	CMMoveValue(v25a, o6, p7b);											/* test 3: move of cont'd */
	CMMoveValue(v25b, o6, p7b);											/* test 4: move of cont'd */
	
	
	/*------------------------*
	 | CMGetOperation() Tests |
	 *------------------------*/
	 
	CMSetMetaHandler(session, "Testing CMGetOperation", containerMetahandler);

	t3 = CMRegisterType(container, "Testing CMGetOperation");
		
	theHandler = CMGetOperation(t3, CMSeekOpType);
	
	if (theHandler != containerMetahandler(NULL, CMSeekOpType)) {
		display(stderr, "### CMGetOperation() failed!\n");
		++failures;
	} else
		++successes;
	
	if (dbgFile && fullTest) CMDumpTOCStructures(container, dbgFile);

	if (dontClose && fullTest) goto readAsis;
	
	/*-------------------------*
	 | CMReleaseObject() Tests |
	 *-------------------------*/
	 
	CMReleaseObject(o1);
	CMReleaseObject(o3);
	CMReleaseObject(o4);
	CMReleaseObject(o5);
	CMReleaseObject(o6);
	CMReleaseObject(p1);
	CMReleaseObject(t1);
	 
	CMCloseContainer(container);
	
	if (!fullTest) return;
	
	/*------------------------------------------------------------------------------------*/
	
	/*-------------------------*
	 | CMReadValueData() tests |
	 *-------------------------*/
	
	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");

	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	CMSetMetaHandler(session, "Debugging2", containerMetahandler);
	container = CMOpenContainer(session, myRefCon, "Debugging2", 0);
	
	if (container == NULL) {
		display(stderr, "### reading tests terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	if (dbgFile && fullTest) CMDumpTOCStructures(container, dbgFile);

readAsis:

	o0 = CMGetNextObject(container, NULL);									/* gets object ID 1						*/
	p0 = CMRegisterProperty(container, CMTOCObjectGlobalName);
	v0 = CMUseValue(o0, p0, TestType(CMTOCValueTypeGlobalName));
	tocSize = CMGetValueSize(v0);
	p0 = CMRegisterProperty(container, CMTOCContainerGlobalName);
	v0 = CMUseValue(o0, p0, TestType(CMTOCValueTypeGlobalName));
	containerSize = CMGetValueSize(v0);
	if (!quiet || showSize) 
		display(stderr, "\nTOC size       = 0x%.8lX = %ld\n"
										  "Container size = 0x%.8lX = %ld\n\n", tocSize, tocSize, containerSize, containerSize);
	if (dontClose && tocSize != 0) {
		display(stderr, "### TOC size test failed! Expected 0. Got 0x%.8lX = %ld\n", tocSize, tocSize);
		++failures;
	 } else if (!dontClose && tocSize != expectedSize) {
	 	sprintf((char *)buffer, "0x%.8lX", expectedSize);
		display(stderr, "### TOC size test failed! Expected %s. Got 0x%.8lX = %ld\n", buffer, tocSize, tocSize);
		++failures;
	} else
		++successes;

	p1 = CMRegisterProperty(container, "property #1");
	p2 = CMRegisterProperty(container, "property #2");
	p3 = CMRegisterProperty(container, "value tests");
	p5 = CMRegisterProperty(container, "insert tests");
	p6 = CMRegisterProperty(container, "delete tests");
	p7a= CMRegisterProperty(container, "move tests (from)");
	p7b= CMRegisterProperty(container, "move tests (to)");
	
	t1 = CMRegisterType(container, "type #1");
	t2 = CMRegisterType(container, "type #2");
	
	if ((o1 = CMGetNextObjectWithProperty(container, NULL, p3)) == NULL) {
		display(stderr, "### cannot find \"value tests\" property in container\n");
		exit(EXIT_FAILURE);
	}
	++successes;
	
	if (!quiet) display(stderr, "Read tests of stuff originally written to container (as-is):\n");
	v1 = CMUseValue(o1, p3, t1);							/* test 1: immediate data */
	amountRead = CMReadValueData(v1, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v1 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v1 = 123 [3]");
	
	CMGetValueInfo(v1, NULL, NULL, NULL, &t0, NULL);
	if (t0 != t1) {
		display(stderr, "### got wrong new type from CMGetValueInfo() during reading\n");
		++failures;
	} else
		++successes;
	
	v2 = CMUseValue(o1, p3, TestType("t2"));	/* test 2: nonimmediate data */
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v2 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v2 = ABCDEFGHIJKLMNOPQRSTUVWXYZ [26]");

	v3 = CMUseValue(o1, p3, TestType("t3"));	/* test 3: pure overwrite of immediate */
	amountRead = CMReadValueData(v3, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v3 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v3 = ABxy [4]");
	
	v4 = CMUseValue(o1, p3, TestType("t4"));	/* test 4: pure overwrite of nonimmediate */
	amountRead = CMReadValueData(v4, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v4 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v4 = 1234567890ABCDEFGHIJ1234567890 [30]");
	
	v5 = CMUseValue(o1, p3, TestType("t5"));	/* test 5: concat to immediate */
	amountRead = CMReadValueData(v5, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v5 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v5 = abCD [4]");
	
	v6 = CMUseValue(o1, p3, TestType("t6"));	/* test 6: concat to non-immediate */
	amountRead = CMReadValueData(v6, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v6 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v6 = 1234567890ABCDE [15]");
	
	v7 = CMUseValue(o1, p3, TestType("t7"));	/* test 7: extend immediate to nonimmediate */
	amountRead = CMReadValueData(v7, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v7 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v7 = 123ABCDE [8]");
	
	v8 = CMUseValue(o1, p3, TestType("t8"));	/* test 8: extend nonimmediate */
	amountRead = CMReadValueData(v8, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v8 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v8 = 12****Test8**** [15]");
	
	v9a = CMUseValue(o1, p3, TestType("t9a"));/* test 9: continued value */
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v9a = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v9a = 1234567890ABCDEFGHIJabcdefghij [30]");
	
	v9b = CMUseValue(o1, p3, TestType("t9b"));
	amountRead = CMReadValueData(v9b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v9b = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v9b = abcdefghij1234567890ABCDEFGHIJ [30]");
	
	v10a = CMUseValue(o1, p3, TestType("t10a"));/* test 10: overwrite of continued value */
	amountRead = CMReadValueData(v10a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v10a = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v10a = ABCDEFG###TEST10###T [20]");
	
	v10b = CMUseValue(o1, p3, TestType("t10b"));
	amountRead = CMReadValueData(v10b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v10b = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v10b = abcdefghijklm***test10*** [25]");
	
	v11 = CMUseValue(o1, p3, TestType("t11"));/* test 11: (over)write of data with size 0 */
	amountRead = CMReadValueData(v11, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v11 = \"%s\" [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v11 = \"\" [0]");
	
	v12 = CMUseValue(o1, p3, TestType("t12"));	
	amountRead = CMReadValueData(v12, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v12 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v12 = test [4]");
	
	v13 = CMUseValue(o1, p3, TestType("t13"));
	amountRead = CMReadValueData(v13, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v13 = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v13 = Ira Ruben [9]");	

	/*-----------------------------------------------------------------------------------*/
	
	if (!quiet) 
		display(stderr, "\nRead tests to test CMReadValueData() in all contortions:\n"
										"    012345678901234567890123456789012345678901234567890\n");
										
	v2 = CMUseValue(o1, p3, TestType("t2"));		/* test 2: nonimmediate data */
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (original input line)", buffer, amountRead);
	checkIt(whatWeGot, "    ABCDEFGHIJKLMNOPQRSTUVWXYZ [26] (original input line)");

	amountRead = CMReadValueData(v2, (CMPtr)buffer, 10, 10);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (10 bytes from offset 10)", buffer, amountRead);
	checkIt(whatWeGot, "    KLMNOPQRST [10] (10 bytes from offset 10)");
	
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 20, 5);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (5 bytes from offset 20)", buffer, amountRead);
	checkIt(whatWeGot, "    UVWXY [5] (5 bytes from offset 20)");
	
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 20, 6);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (6 bytes from offset 20)", buffer, amountRead);
	checkIt(whatWeGot, "    UVWXYZ [6] (6 bytes from offset 20)");
	
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 21, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (256 bytes from offset 21)", buffer, amountRead);
	checkIt(whatWeGot, "    VWXYZ [5] (256 bytes from offset 21)");
	
	amountRead = CMReadValueData(v2, (CMPtr)buffer, 13, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (256 bytes from offset 13)", buffer, amountRead);
	checkIt(whatWeGot, "    NOPQRSTUVWXYZ [13] (256 bytes from offset 13)");
	
	if (!quiet) display(stderr, "\n    012345678901234567890123456789012345678901234567890\n");
	v9a = CMUseValue(o1, p3, TestType("t9a"));
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (3-seg. continued value)", buffer, amountRead);
	checkIt(whatWeGot, "    1234567890ABCDEFGHIJabcdefghij [30] (3-seg. continued value)");
	
	v9a = CMUseValue(o1, p3, TestType("t9a"));
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 4, 10);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (10 bytes from offset 4)", buffer, amountRead);
	checkIt(whatWeGot, "    567890ABCD [10] (10 bytes from offset 4)");
	
	v9a = CMUseValue(o1, p3, TestType("t9a"));
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 12, 6);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (6 bytes from offset 12)", buffer, amountRead);
	checkIt(whatWeGot, "    CDEFGH [6] (6 bytes from offset 12)");
	
	v9a = CMUseValue(o1, p3, TestType("t9a"));
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 12, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (256 bytes from offset 12)", buffer, amountRead);
	checkIt(whatWeGot, "    CDEFGHIJabcdefghij [18] (256 bytes from offset 12)");
	
	v9a = CMUseValue(o1, p3, TestType("t9a"));
	amountRead = CMReadValueData(v9a, (CMPtr)buffer, 4, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (256 bytes from offset 4)", buffer, amountRead);
	checkIt(whatWeGot, "    567890ABCDEFGHIJabcdefghij [26] (256 bytes from offset 4)");
	
	/*-----------------------------------------------------------------------------------*/
	
	if (!quiet) 
		display(stderr, "\nRead tests of inserts:\n"
										"    012345678901234567890123456789012345678901234567890\n");
	if ((o3 = CMGetNextObjectWithProperty(container, NULL, p5)) == NULL) {
		display(stderr, "### cannot find \"insert tests\" property in container\n");
		exit(EXIT_FAILURE);
	}
	++successes;
	
	v17a = CMUseValue(o3, p5, TestType("t17a"));
	v17b = CMUseValue(o3, p5, TestType("t17b"));
	v18  = CMUseValue(o3, p5, TestType("t18"));
	v19a = CMUseValue(o3, p5, TestType("t19a"));
	v19b = CMUseValue(o3, p5, TestType("t19b"));
	
	amountRead = CMReadValueData(v17a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (small insert into small insert)", buffer, amountRead);
	sprintf((char *)buffer, "    wxyz [4] (small insert into small insert)");
	checkIt(whatWeGot, (char *)buffer);
	
	amountRead = CMReadValueData(v17b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (large insert into insert)", buffer, amountRead);
	checkIt(whatWeGot, "    ABCDEFGH [8] (large insert into insert)");
	
	amountRead = CMReadValueData(v18, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (insert into non-immediate)", buffer, amountRead);
	checkIt(whatWeGot, "    ABCDEFGHI1234567890JKLMNOPQRSTUVWXYZ [36] (insert into non-immediate)");
	
	amountRead = CMReadValueData(v19a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (insert into middle of cont'd seg)", buffer, amountRead);
	checkIt(whatWeGot, "    1234567890ABCDE<insert>FGHIJabcdefghij [38] (insert into middle of cont'd seg)");
	
	amountRead = CMReadValueData(v19b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (insert into start of cont'd seg)", buffer, amountRead);
	checkIt(whatWeGot, "    abcdefghij1234567890<insert>ABCDEFGHIJ [38] (insert into start of cont'd seg)");
	
	/*-----------------------------------------------------------------------------------*/
	
	if (!quiet) 
		display(stderr, "\nRead tests of deletes:\n"
										"    012345678901234567890123456789012345678901234567890\n");
	if ((o4 = CMGetNextObjectWithProperty(container, NULL, p6)) == NULL) {
		display(stderr, "### cannot find \"delete tests\" property in container\n");
		exit(EXIT_FAILURE);
	}
	++successes;
	
	v20a = CMUseValue(o4, p6, TestType("t20a"));
	v20b = CMUseValue(o4, p6, TestType("t20b"));
	v21a = CMUseValue(o4, p6, TestType("t21a"));
	v21b = CMUseValue(o4, p6, TestType("t21b"));
	v22a = CMUseValue(o4, p6, TestType("t22a"));
	v22b = CMUseValue(o4, p6, TestType("t22b"));
	v22c = CMUseValue(o4, p6, TestType("t22c"));
	v22d = CMUseValue(o4, p6, TestType("t22d"));
				
	amountRead = CMReadValueData(v20a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of immediate)", buffer, amountRead);
	checkIt(whatWeGot, "    AD [2] (delete of immediate)");
	
	amountRead = CMReadValueData(v20b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of entire immediate)", buffer, amountRead);
	checkIt(whatWeGot, "     [0] (delete of entire immediate)");
	
	amountRead = CMReadValueData(v21a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of immediate)", buffer, amountRead);
	checkIt(whatWeGot, "    ABCDEFGHIJTUVWXYZ [17] (delete of immediate)");
				
	amountRead = CMReadValueData(v21b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of entire non-immediate)", buffer, amountRead);
	checkIt(whatWeGot, "     [0] (delete of entire non-immediate)");
	
	amountRead = CMReadValueData(v22a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of cont'd)", buffer, amountRead);
	checkIt(whatWeGot, "    12345efghij [11] (delete of cont'd)");
	
	amountRead = CMReadValueData(v22b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of cont'd - part of last seg)", buffer, amountRead);
	checkIt(whatWeGot, "    abcdefghij1234567890ABCHIJ [26] (delete of cont'd - part of last seg)");
	
	amountRead = CMReadValueData(v22c, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of cont'd - seg to end)", buffer, amountRead);
	checkIt(whatWeGot, "    12345 [5] (delete of cont'd - seg to end)");
	
	amountRead = CMReadValueData(v22d, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (delete of cont'd - middle seg to end)", buffer, amountRead);
	checkIt(whatWeGot, "    1234567890ABCDE [15] (delete of cont'd - middle seg to end)");
	
	/*-----------------------------------------------------------------------------------*/
	
	if (!quiet) 
		display(stderr, "\nRead tests of moved objects:\n"
										"    012345678901234567890123456789012345678901234567890\n");
	if ((o6 = CMGetNextObjectWithProperty(container, NULL, p7b)) == NULL) {
		display(stderr, "### cannot find \"move tests\" property in container\n");
		exit(EXIT_FAILURE);
	}
	++successes;
	
	v23  = CMUseValue(o6, p7b, TestType("t23"));
	v24  = CMUseValue(o6, p7b, TestType("t24"));
	v25a = CMUseValue(o6, p7b, TestType("t25a"));
	v25b = CMUseValue(o6, p7b, TestType("t25b"));
	
	amountRead = CMReadValueData(v23, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (move of immediate)", buffer, amountRead);
	checkIt(whatWeGot, "    dcba [4] (move of immediate)");
	
	amountRead = CMReadValueData(v24, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (move of non-immediate)", buffer, amountRead);
	checkIt(whatWeGot, "    ABCDEFGHIJKLMNOPQRSTUVWXYZ [26] (move of non-immediate)");
	
	amountRead = CMReadValueData(v25a, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (move of cont'd)", buffer, amountRead);
	checkIt(whatWeGot, "    1234567890ABCDEFGHIJabcdefghij [30] (move of cont'd)");
	
	amountRead = CMReadValueData(v25b, (CMPtr)buffer, 0, 255);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    %s [%ld] (move of last cont'd)", buffer, amountRead);
	checkIt(whatWeGot, "    abcdefghij1234567890ABCDEFGHIJ [30] (move of last cont'd)");
	
	/*-------------------------*
	 | CMReleaseObject() Tests |
	 *-------------------------*/
	 
	CMReleaseObject(o1);
	CMReleaseObject(o3);
	CMReleaseObject(o4);
	CMReleaseObject(o6);
	CMReleaseObject(p1);
	CMReleaseObject(t1);
		
	CMCloseContainer(container);
}


/*-------------------*
 | doConvertingTests |
 *-------------------*/

static void CM_NEAR doConvertingTests(void)
{
	CMContainer 	 container;
	CMRefCon		 	 myRefCon;
	CMSize				 amountRead;
	int 					 i;
	char  				 typeName[30], buffer[256];
	CMType				 t0, t1;
	CMProperty		 p1;
	CMObject			 o1;
	CMValue				 v1;

	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");
	 
	strcpy(filename, origFilename);
	strcat(filename, "XF"           );
	
	if (!quiet) {
		display(stderr, "\nFile we are converting to container is: \"%s\"\n\n", filename);
		display(stderr, "Converting tests...\n");
	}
	
	/*-----------------------------------------*
	 | Converting Tests - doing the conversion |
	 *-----------------------------------------*/
	
	rawDataFile = fopen(filename, "w");
	if (rawDataFile == NULL) {
		display(stderr, "I/O error while trying to open \"%s\"\n", filename);
		exit(EXIT_FAILURE);
	}																																	/* offsets */
	fwrite("line 1", 1, 6, rawDataFile);															/* 00 - 05 */
	fwrite("line 2", 1, 6, rawDataFile);															/* 06 - 11 */
	fwrite("line 3", 1, 6, rawDataFile);															/* 12 - 17 */
	fwrite("line 4", 1, 6, rawDataFile);															/* 18 - 23 */
	fwrite("line 5", 1, 6, rawDataFile);															/* 24 - 29 */
	fwrite("line 6", 1, 6, rawDataFile);															/* 30 - 35 */
	fwrite("line 7", 1, 6, rawDataFile);															/* 36 - 41 */
	fwrite("line 8", 1, 6, rawDataFile);															/* 42 - 47 */
	fwrite("line 9", 1, 6, rawDataFile);															/* 48 - 53 */
	fwrite("line 10 ABCDEFGHIJKLMNOPQRSTUVWXYZ",1, 34, rawDataFile);	/* 54 - 87 */
	fclose(rawDataFile);
	
	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	CMSetMetaHandler(session, "Debugging3", containerMetahandler);
	container = CMOpenNewContainer(session, myRefCon, "Debugging3", kCMConverting, 1, 0);
	
	if (container == NULL) {
		display(stderr, "### converting tests (creating) terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	p1 = CMRegisterProperty(container, "converted values");
	t1 = CMRegisterType(container, "type of converted values");
	
	o1 = CMNewObject(container);
	for (i = 0; i < 9; ++i) {
		sprintf(typeName, "type#%ld", i + 1);
		v1 = CMNewValue(o1, p1, TestType(typeName));
		CMDefineValueData(v1, i * 6, 6);
	}
	
	/*
	1234567890123456789012345678901234
	0123456789012345678901234567890123
	5     6         7         8
	4567890123456789012345678901234567
	line 10 ABCDEFGHIJKLMNOPQRSTUVWXYZ
	
	line 10 ABCDEMNOPQRVWXYZ
	*/
	
	v1 = CMNewValue(o1, p1, TestType("type#10"));
	CMDefineValueData(v1, 54, 7);									/* testing define with multiple segments*/
	CMDefineValueData(v1, 54+7, 6);								/* test 1: a concatenated segment 			*/
	CMDefineValueData(v1, 74, 6);									/* test 2: a non-contiguous segment			*/
	CMDefineValueData(v1, 83, 5);									/* test 3: another											*/
	
	if (dbgFile) CMDumpTOCStructures(container, dbgFile);
	
	if (dontClose) goto readConversion;
	CMCloseContainer(container);
	
	/*------------------------------------------------------------------------------------*/

	/*------------------------------------------------------------*
	 | Converting Tests - reading the converted-to-container file |
	 *------------------------------------------------------------*/
	
	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");

	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	CMSetMetaHandler(session, "Debugging4", containerMetahandler);
	container = CMOpenContainer(session, myRefCon, "Debugging4", 0);
	
	if (container == NULL) {
		display(stderr, "### converting tests (reading) terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	if (dbgFile) CMDumpTOCStructures(container, dbgFile);

readConversion:

	p1 = CMRegisterProperty(container, "converted values");
	t1 = CMRegisterType(container, "type of converted values");
	
	if ((o1 = CMGetNextObjectWithProperty(container, NULL, p1)) == NULL) {
		display(stderr, "### cannot find \"converted values\" property in container\n");
		exit(EXIT_FAILURE);
	}
	++successes;
	
	if (!quiet) display(stderr, "\nRead of converted container:\n");
		
	for (i = 1;; ++i) {
		sprintf(typeName, "type#%ld", i);
		v1 = CMUseValue(o1, p1, TestType(typeName));
		amountRead = CMReadValueData(v1, (CMPtr)buffer, 0, 255);
		if (amountRead == 0) break;
		*(buffer+amountRead) = 0;
		sprintf(whatWeGot, "    %s [%ld]", buffer, amountRead);
		if (i < 10) {
			sprintf(buffer, "    line %ld [6]", i);
			checkIt(whatWeGot, buffer);
		} else {
			sprintf(whatWeGot, "    %s [%ld] (cont'd defined)", buffer, amountRead);
			checkIt(whatWeGot, "    line 10 ABCDEMNOPQRVWXYZ [24] (cont'd defined)");
		}
		
		CMGetValueInfo(v1, NULL, NULL, NULL, &t0, NULL);
		if (t0 != TestType(typeName)) {
			display(stderr, "    ### got wrong type from CMReadValueData() (converting read tests)\n");
			++failures;
		} else
			++successes;
	} /* for */
		
	if (i != 11) {
		display(stderr, "    ### not all converted data was read!\n");
		++failures;
	} else
		++successes;
	
	CMCloseContainer(container);
}


/*------------------*
 | doReferenceTests |
 *------------------*/

static void CM_NEAR doReferenceTests(void)
{
	CMContainer 	 container;
	CMRefCon			 myRefCon;
	CMType				 t1, t2;
	CMProperty		 p1, p2;
	CMObject			 testO, o[9];
	CMValue				 testV, v[9];
	CMReference		 currRef, refData[7];
	CMSize				 amountRead;
	short					 i, j, n;
	unsigned char  buffer[256];

	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");
	 
	strcpy(filename, origFilename);
	strcat(filename, "Ref"     );
	
	if (!quiet) {
		display(stderr, "\nContainer we are using is: \"%s\"\n\n", filename);
		display(stderr, "Reference tests...\n");
	}

	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	CMSetMetaHandler(session, "DebuggingRefs1", containerMetahandler);
	container = CMOpenNewContainer(session, myRefCon, "DebuggingRefs1",
																 (CMContainerUseMode)(reuseSpace ? kCMReuseFreeSpace : 0),
																 1, 0);
	if (container == NULL) {
		display(stderr, "### reference tests (creation) terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	for (i = 0; i < 7; ++i)
		for (j = 0; j < sizeof(CMReference); ++j)
			refData[i][j] = 0x00;
	
	p1 = CMRegisterProperty(container, "target referenced property");
	t1 = CMRegisterType(container, "target referenced type");
	
	p2 = CMRegisterProperty(container, "referencing property");
	t2 = CMRegisterType(container, "referencing type");
	
	for (i = 0; i < 9; ++i) {												/* create 9 objects with 1 value each	*/
		o[i] = CMNewObject(container);								/* o[i] 															*/
		v[i] = CMNewValue(o[i], p1, t1);							/* o[i] contains value v[i]						*/
		sprintf((char *)buffer, "v[%d]", i);					/* value data for v[i] is "v[i]"			*/
		CMWriteValueData(v[i], (CMPtr)buffer, 0, 4);
	}
	
	/* Create the referencing object which will contain the references to the 7 objects...*/
	
	testO = CMNewObject(container);									/* object "owning" the references"		*/
	testV = CMNewValue(testO, p2, t2);							/* object's value to get refs as data	*/
	
	/*------------------------*
	 | CMNewReference() Tests |
	 *------------------------*/
	 
	/* Create 5 references to the first five target objects...														*/
	
	for (i = 0; i < 5; ++i)													/* create refs to 5 target objects		*/
		memcpy(refData[i], CMNewReference(testV, o[i], refData[i]), sizeof(CMReference));
	
	/*------------------------*
	 | CMSetReference() Tests |
	 *------------------------*/
	
	/* Create 2 additional objects using CMSetReference() and change the 2nd and 4th 			*/
	/* reference to assoiciate to the 8th and 9th objects respectively.  We should end		*/
	/* up with 7 references to 7 objects and there will be no references to o[1] and o[3].*/

	memcpy(refData[5], "ref5", sizeof(CMReference));
	CMSetReference(testV, o[5], refData[5]);
	memcpy(refData[6], "ref6", sizeof(CMReference));
	CMSetReference(testV, o[6], refData[6]);

	CMSetReference(testV, o[7], refData[1]);
	CMSetReference(testV, o[8], refData[3]);
	
	CMWriteValueData(testV, (CMPtr)"<<<<", 0, 4);
	CMWriteValueData(testV, (CMPtr)refData, 4, 7 * sizeof(CMReference));
	CMWriteValueData(testV, (CMPtr)">>>>", 4 + 7 * sizeof(CMReference), 4);
	
	if (dbgFile) CMDumpTOCStructures(container, dbgFile);

	if (dontClose) goto readAsis;
	 
	CMCloseContainer(container);
	
	/*------------------------------------------------------------------------------------*/
		
	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");

	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	CMSetMetaHandler(session, "DebuggingRefs2", containerMetahandler);
	container = CMOpenContainer(session, myRefCon, "DebuggingRefs2", 0);
	
	if (container == NULL) {
		display(stderr, "### reference tests (reading) terminated: container == NULL\n");
		exit(EXIT_FAILURE);
	}
	
	if (dbgFile) CMDumpTOCStructures(container, dbgFile);

readAsis:
	
	p1 = CMRegisterProperty(container, "target referenced property");
	t1 = CMRegisterType(container, "target referenced type");
	
	p2 = CMRegisterProperty(container, "referencing property");
	t2 = CMRegisterType(container, "referencing type");
	
	if ((testO = CMGetNextObjectWithProperty(container, NULL, p2)) == NULL) {
		display(stderr, "### cannot find \"referencing\" property in container\n");
		exit(EXIT_FAILURE);
	}
	testV = CMUseValue(testO, p2, t2);
	
	if (CMReadValueData(testV, (CMPtr)refData, 4, 7 * sizeof(CMReference)) != 7 * sizeof(CMReference)) {
		display(stderr, "### Reference value data was not fully read.\n");
		exit(EXIT_FAILURE);
	}

	/*--------------------------*
	 | CMCountReferences() Test |
	 *--------------------------*/
	
	n = (short)CMCountReferences(testV);
	
	if (n != 7) {
		display(stderr, "### CMCountReferences() returned %d references (should be 7)\n", n);
		exit(EXIT_FAILURE);
	}
	++successes;
	
	/*-------------------------------*
	 | CMGetReferencedObject() Tests |
	 *-------------------------------*/
	 
	/* The 2nd and 4th reference assoiciate to the 8th and 9th objects respectively.  		*/

	/* Get each reference and verify it...																								*/ 
	
	for (i = 0; i < n; ++i) {
		if (i == 1)
			j = 7;
		else if (i == 3)
			j = 8;
		else
			j = i;

		o[j] = CMGetReferencedObject(testV, refData[i]);
		if (o[j] == NULL) {
			display(stderr, "### CMGetReferencedObject() failed.\n");
			exit(EXIT_FAILURE);
		}
		++successes;
		
		v[j] = CMUseValue(o[j], p1, t1);
		if (v[j] == NULL) {
			display(stderr, "### Cannot get referenced object's value (%d)\n", j);
			exit(EXIT_FAILURE);
		}
		++successes;
		
		amountRead = CMReadValueData(v[j], (CMPtr)buffer, 0, 255);
		*(buffer+amountRead) = 0;
		sprintf(whatWeGot, "    v[%d] = \"%s\"", j, buffer);
		sprintf((char *)buffer,    "    v[%d] = \"v[%d]\"", j, j);
		checkIt(whatWeGot, (char *)buffer);
	}
	
	/*----------------------------*
	 | CMGetNextReference() Tests |
	 *----------------------------*/

	for (i = 0; i < sizeof(CMReference); ++i) currRef[i] = 0x00;
	i = 0;
	
	while (CMGetNextReference(testV, currRef)) {
		if (i == 1)
			j = 7;
		else if (i == 3)
			j = 8;
		else
			j = i;
			
		o[j] = CMGetReferencedObject(testV, currRef);
		if (o[j] == NULL) {
			display(stderr, "### CMGetReferencedObject() failed using CMGetNextReference().\n");
			exit(EXIT_FAILURE);
		}
		++successes;
		
		v[j] = CMUseValue(o[j], p1, t1);
		if (v[j] == NULL) {
			display(stderr, "### Cannot get referenced object's value (%d, using CMGetNextReference())\n", j);
			exit(EXIT_FAILURE);
		}
		++successes;
		
		amountRead = CMReadValueData(v[j], (CMPtr)buffer, 0, 255);
		*(buffer+amountRead) = 0;
		sprintf(whatWeGot, "    v[%d] = \"%s\"", j, buffer);
		sprintf((char *)buffer,    "    v[%d] = \"v[%d]\"", j, j);
		checkIt(whatWeGot, (char *)buffer);
		
		++i;
	}
	
	if (i != 7) {
		display(stderr, "### CMGetNextReference() got only %d references (should be 7)\n", i);
		exit(EXIT_FAILURE);
	}
	++successes;

	CMCloseContainer(container);
}


/*-----------------*
 | doEmbeddedTests |
 *-----------------*/

static void CM_NEAR doEmbeddedTests(void)
{
	CMContainer	level1, level11, level12, level111, level112, level1121;
	CMType			t1[10], t11[10], t12[10], t111[10], t112[10], t1121[10];
	CMProperty	p1[10], p11[10], p12[10], p111[10], p112[10], p1121[10];
	CMObject		o1[10], o11[10], o12[10], o111[10], o112[10], o1121[10];
	CMValue			v1[10], v11[10], v12[10], v111[10], v112[10], v1121[10];
	CMValue			ev11, ev12, ev111, ev112, ev1121;
	CMRefCon		myRefCon11, myRefCon12, myRefCon111, myRefCon112, myRefCon1121; 
	
	CMRefCon			 myRefCon;
	CMSize				 amountRead;
	unsigned char  buffer[256];
	
	#undef TestType
	#define TestType(c, t) (CMRegisterType(c, (CMGlobalName)t))

	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");
	
	strcpy(filename, origFilename);
	strcat(filename, "Emb"          );

	/*---------------------------------------------------------------------------------*
	 | Embedded Container Tests - creating a REALLY embedded container (go for broke!) |
	 *---------------------------------------------------------------------------------*/

	if (!quiet) {
		display(stderr, "\nContainer we are using is for embedding tests is: \"%s\"\n\n", filename);
	
		display(stderr, "Creating embedded containers with the following tree structure:\n\n"
										"               level1           This is the embedding structure this test\n"
										"       level11        level12   will simulate. View this as a tree with\n");
		display(stderr, " level111   level112            1 or 2 descendents. A descendent is\n"
										"            level1121           nested in its parent. They're all nested\n"
										"                                in level1 here. The level names represent\n"
										"                                containers of course.\n");
		if (dontClose) display(stderr, "\n");
	}
	
	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
		
	/*--------*
	 | level1 |
	 *--------*/
	 
	CMSetMetaHandler(session, "level1", containerMetahandler);
	level1 = CMOpenNewContainer(session, myRefCon, "level1", 0, 1, 0);
	if (level1 == NULL) {
		display(stderr, "### embedded tests (writing) terminated: level1 == NULL\n");
		exit(EXIT_FAILURE);
	}
	if (dbgEmbedded) display(stderr, "level1 = $%.8lX\n", level1);
	p1[1] = CMRegisterProperty(level1, "property1:level 1");
	p1[2] = CMRegisterProperty(level1, "property2:level 1");
	t1[1] = CMRegisterType(level1, "type:level 1");
	
	o1[1] = CMNewObject(level1);																 /* 2 embeds on 2 objects */
	ev11  = CMNewValue(o1[1], p1[1], TestType(level1, "ev11"));
	
	o1[2] = CMNewObject(level1);
	ev12  = CMNewValue(o1[2], p1[2], TestType(level1, "ev12"));
	
	p1[3] = CMRegisterProperty(level1, "level 1a: data");
	o1[3] = CMNewObject(level1);
	v1[3] = CMNewValue(o1[3], p1[3], t1[1]);
	
	p1[4] = CMRegisterProperty(level1, "level 1b: data");
	o1[4] = CMNewObject(level1);
	v1[4] = CMNewValue(o1[4], p1[4], t1[1]);
	
	CMWriteValueData(v1[3], (CMPtr)"level1a: 1234567890", 0, 19);
	CMWriteValueData(v1[4], (CMPtr)"level1b: ABCDEFGHIJ", 0, 19);
	
				/*---------*
				 | level11 |
				 *---------*/

				myRefCon11 = createRefConForMyEmbHandlers(ev11);
				setEmbeddedHandlersTrace(myRefCon11, traceHandlers, handlerDbgFile);
				CMSetMetaHandler(session, "level11", embeddedContainerMetahandler);
				level11 = CMOpenNewContainer(session, myRefCon11, "level11", 0, 1, 0);
				if (level11 == NULL) {
					display(stderr, "### embedded tests (writing) terminated: level11 == NULL\n");
					exit(EXIT_FAILURE);
				}
				if (dbgEmbedded) display(stderr, "level11 = $%.8lX\n", level11);
				p11[1] = CMRegisterProperty(level11, "property:level 1,1");
				t11[1] = CMRegisterType(level11, "type:level 1,1");
				
				o11[1] = CMNewObject(level11);
				ev111  = CMNewValue(o11[1], p11[1], TestType(level11, "ev111"));	/* 2 embeds for 1 object*/
				ev112  = CMNewValue(o11[1], p11[1], TestType(level11, "ev112"));
	
				o11[3] = CMNewObject(level11);
				p11[3] = CMRegisterProperty(level11, "level 11: data");
				v11[3] = CMNewValue(o11[3], p11[3], t11[1]);

				CMWriteValueData(v1[3], (CMPtr)"ABCDEFGHIJ", CMGetValueSize(v1[3]), 10);
				CMWriteValueData(v11[3], (CMPtr)"level11: 1234567890", 0, 19);
				CMWriteValueData(v1[4], (CMPtr)"1234567890", CMGetValueSize(v1[4]), 10);
				
						/*----------*
						 | level111 |
						 *----------*/

						myRefCon111 = createRefConForMyEmbHandlers(ev111);
						setEmbeddedHandlersTrace(myRefCon111, traceHandlers, handlerDbgFile);
						CMSetMetaHandler(session, "level111", embeddedContainerMetahandler);
						level111 = CMOpenNewContainer(session, myRefCon111, "level111", 0, 1, 0);
						if (level111 == NULL) {
							display(stderr, "### embedded tests (writing) terminated: level111 == NULL\n");
							exit(EXIT_FAILURE);
						}
						if (dbgEmbedded) display(stderr, "level111 = $%.8lX\n", level111);
						p111[1] = CMRegisterProperty(level111, "property:level 1,1,1");
						t111[1] = CMRegisterType(level111, "type:level 1,1,1");
	
						o111[3] = CMNewObject(level111);
						p111[3] = CMRegisterProperty(level111, "level 111: data");
						v111[3] = CMNewValue(o111[3], p111[3], t111[1]);
						
						CMWriteValueData(v111[3], (CMPtr)"level111: ABCDEFGHIJ", 0, 20);
						CMWriteValueData(v11[3], (CMPtr)"ABCDEFGHIJ", CMGetValueSize(v11[3]), 10);
						
						/*----------*
						 | level112 |
						 *----------*/

						myRefCon112 = createRefConForMyEmbHandlers(ev112);
						setEmbeddedHandlersTrace(myRefCon112, traceHandlers, handlerDbgFile);
						CMSetMetaHandler(session, "level112", embeddedContainerMetahandler);
						level112 = CMOpenNewContainer(session, myRefCon112, "level112", 0, 1, 0);
						if (level112 == NULL) {
							display(stderr, "### embedded tests (writing) terminated: level112 == NULL\n");
							exit(EXIT_FAILURE);
						}
						if (dbgEmbedded) display(stderr, "level112 = $%.8lX\n", level112);
						
						p112[1] = CMRegisterProperty(level112, "property:level 1,1,2");
						t112[1] = CMRegisterType(level112, "type:level 1,1,2");
						
						o112[1] = CMNewObject(level112);
						ev1121  = CMNewValue(o112[1], p112[1], TestType(level112, "ev1121"));

						o112[3] = CMNewObject(level112);
						p112[3] = CMRegisterProperty(level112, "level 112: data");
						v112[3] = CMNewValue(o112[3], p112[3], t112[1]);
						
						CMWriteValueData(v111[3], (CMPtr)"1234567890", CMGetValueSize(v111[3]), 10);
						CMWriteValueData(v112[3], (CMPtr)"level112: ABCDEFGHIJ", 0, 20);
						
									/*-----------*
									 | level1121 |
									 *-----------*/

									myRefCon1121 = createRefConForMyEmbHandlers(ev1121);
									setEmbeddedHandlersTrace(myRefCon1121, traceHandlers, handlerDbgFile);
									CMSetMetaHandler(session, "level1121", embeddedContainerMetahandler);
									level1121 = CMOpenNewContainer(session, myRefCon1121, "level1121", 0, 1, 0);
									if (level1121 == NULL) {
										display(stderr, "### embedded tests (writing) terminated: level1121 == NULL\n");
										exit(EXIT_FAILURE);
									}
									if (dbgEmbedded) display(stderr, "level1121 = $%.8lX\n", level1121);
									p1121[1] = CMRegisterProperty(level1121, "property:level 1,1,2,1");
									t1121[1] = CMRegisterType(level1121, "type:level 1,1,2,1");

									o1121[3] = CMNewObject(level1121);
									p1121[3] = CMRegisterProperty(level1121, "level 1121: data");
									v1121[3] = CMNewValue(o1121[3], p1121[3], t1121[1]);
									
									CMWriteValueData(v1121[3], (CMPtr)"level1121: 1234567890", 0, 21);
									CMWriteValueData(v112[3], (CMPtr)"1234567890", CMGetValueSize(v112[3]), 10);

				/*---------*
				 | level12 |
				 *---------*/

				myRefCon12 = createRefConForMyEmbHandlers(ev12);
				setEmbeddedHandlersTrace(myRefCon12, traceHandlers, handlerDbgFile);
				CMSetMetaHandler(session, "level12", embeddedContainerMetahandler);
				level12 = CMOpenNewContainer(session, myRefCon12, "level12", 0, 1, 0);
				if (level12 == NULL) {
					display(stderr, "### embedded tests (writing) terminated: level12 == NULL\n");
					exit(EXIT_FAILURE);
				}
				if (dbgEmbedded) display(stderr, "level12 = $%.8lX\n", level12);
				p12[1] = CMRegisterProperty(level12, "property:level 1,2");
				t12[1] = CMRegisterType(level12, "type:level 1,2");

				o12[3] = CMNewObject(level12);
				p12[3] = CMRegisterProperty(level12, "level 12: data");
				v12[3] = CMNewValue(o12[3], p12[3], t12[1]);
				
				CMWriteValueData(v1121[3], (CMPtr)"ABCDEFGHIJ", CMGetValueSize(v1121[3]), 10);
				CMWriteValueData(v12[3], (CMPtr)"level12: 1234567890", 0, 19);
				CMWriteValueData(v12[3], (CMPtr)"ABCDEFGHIJ1234567890: level12", CMGetValueSize(v12[3]), 29);
				CMWriteValueData(v1121[3], (CMPtr)"1234567890: level1121", CMGetValueSize(v1121[3]), 21);
	
	if (dontClose) {
		CMWriteValueData(v1[3], (CMPtr)"1234567890: level1a", CMGetValueSize(v1[3]), 19);
		CMWriteValueData(v1[4], (CMPtr)"ABCDEFGHIJ: level1b", CMGetValueSize(v1[4]), 19);
		CMWriteValueData(v112[3], (CMPtr)"ABCDEFGHIJ: level112", CMGetValueSize(v112[3]), 20);
		CMWriteValueData(v11[3], (CMPtr)"1234567890: level11", CMGetValueSize(v11[3]), 19);
		CMWriteValueData(v111[3], (CMPtr)"ABCDEFGHIJ: level111", CMGetValueSize(v111[3]), 20);
		goto readEmbedded;
	}

	if (dbgFile && !fullEmbedClose) {
		display(dbgFile, "level12\n");
		CMDumpTOCStructures(level12, dbgFile);
		CMCloseContainer(level12);
		CMWriteValueData(v1[3], (CMPtr)"1234567890: level1a", CMGetValueSize(v1[3]), 19);
		CMWriteValueData(v1[4], (CMPtr)"ABCDEFGHIJ: level1b", CMGetValueSize(v1[4]), 19);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level1121\n");
		CMDumpTOCStructures(level1121, dbgFile);
		CMCloseContainer(level1121);
		CMWriteValueData(v112[3], (CMPtr)"ABCDEFGHIJ: level112", CMGetValueSize(v112[3]), 20);
		CMWriteValueData(v11[3], (CMPtr)"1234567890: level11", CMGetValueSize(v11[3]), 19);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level112\n");
		CMDumpTOCStructures(level112, dbgFile);
		CMCloseContainer(level112);
		CMWriteValueData(v111[3], (CMPtr)"ABCDEFGHIJ: level111", CMGetValueSize(v111[3]), 20);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level111\n");
		CMDumpTOCStructures(level111, dbgFile);
		CMCloseContainer(level111);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level11\n");
		CMDumpTOCStructures(level11, dbgFile);
		CMCloseContainer(level11);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level1\n");
		CMDumpTOCStructures(level1, dbgFile);
		CMCloseContainer(level1);
		display(dbgFile, "################################################\n");
	} else {
		CMWriteValueData(v1[3], (CMPtr)"1234567890: level1a", CMGetValueSize(v1[3]), 19);
		CMWriteValueData(v1[4], (CMPtr)"ABCDEFGHIJ: level1b", CMGetValueSize(v1[4]), 19);
		CMWriteValueData(v112[3], (CMPtr)"ABCDEFGHIJ: level112", CMGetValueSize(v112[3]), 20);
		CMWriteValueData(v11[3], (CMPtr)"1234567890: level11", CMGetValueSize(v11[3]), 19);
		CMWriteValueData(v111[3], (CMPtr)"ABCDEFGHIJ: level111", CMGetValueSize(v111[3]), 20);
		CMCloseContainer(level1);	
	}
	
	/*--------------------------------------------------------------------------*
	 | Embedded Container Tests - reading the embedded containers created above |
	 *--------------------------------------------------------------------------*/
	
	if (dbgFile) 
		display(dbgFile, "--------------------------------------------------------------------------\n");
	
	if (!quiet) display(stderr, "\nRead tests to test CMReadValueData() of embedded containers:\n");

	myRefCon = createRefConForMyHandlers(session, filename, NULL);
	setHandlersTrace(myRefCon, traceHandlers, handlerDbgFile);
	
	/*--------*
	 | level1 |
	 *--------*/

	if (dbgFile) display(dbgFile, "\nlevel1\n");
	CMSetMetaHandler(session, "level1", containerMetahandler);
	level1 = CMOpenContainer(session, myRefCon, "level1", 0);
	if (level1 == NULL) {
		display(stderr, "### embedded tests (reading) terminated: level1 == NULL\n");
		exit(EXIT_FAILURE);
	}
	p1[1] = CMRegisterProperty(level1, "property1:level 1");
	p1[2] = CMRegisterProperty(level1, "property2:level 1");
	t1[1] = CMRegisterType(level1, "type:level 1");
	if ((o1[1] = CMGetNextObjectWithProperty(level1, NULL, p1[1])) == NULL) {	/* 2 embeds on 2 objects */
		display(stderr, "### cannot find property in container (level1)\n");
		exit(EXIT_FAILURE);
	}
	ev11 = CMUseValue(o1[1], p1[1], TestType(level1, "ev11"));													
	
	if ((o1[2] = CMGetNextObjectWithProperty(level1, NULL, p1[2])) == NULL) {
		display(stderr, "### cannot find property in container (level1)\n");
		exit(EXIT_FAILURE);
	}
	ev12 = CMUseValue(o1[2], p1[2], TestType(level1, "ev12"));
	
				/*---------*
				 | level11 |
				 *---------*/

				if (dbgFile) display(dbgFile, "\nlevel11\n");
				myRefCon11 = createRefConForMyEmbHandlers(ev11);
				setEmbeddedHandlersTrace(myRefCon11, traceHandlers, handlerDbgFile);
				level11 = CMOpenContainer(session, myRefCon11, "level11", 0);
				if (level11 == NULL) {
					display(stderr, "### embedded tests (reading) terminated: level11 == NULL\n");
					exit(EXIT_FAILURE);
				}
				p11[1] = CMRegisterProperty(level11, "property:level 1,1");
				t11[1] = CMRegisterType(level11, "type:level 1,1");
				if ((o11[1] = CMGetNextObjectWithProperty(level11, NULL, p11[1])) == NULL) {
					display(stderr, "### cannot find property in container (level11)\n");
					exit(EXIT_FAILURE);
				}
				ev111 = CMUseValue(o11[1], p11[1], TestType(level11, "ev111"));	/* 2 embeds for 1 object */
				ev112 = CMUseValue(o11[1], p11[1], TestType(level11, "ev112"));
				
						/*----------*
						 | level111 |
						 *----------*/
						 
						if (dbgFile) display(dbgFile, "\nlevel111\n");
						myRefCon111 = createRefConForMyEmbHandlers(ev111);
						setEmbeddedHandlersTrace(myRefCon111, traceHandlers, handlerDbgFile);
						level111 = CMOpenContainer(session, myRefCon111, "level111", 0);
						if (level111 == NULL) {
							display(stderr, "### embedded tests (reading) terminated: level111 == NULL\n");
							exit(EXIT_FAILURE);
						}
						p111[1] = CMRegisterProperty(level111, "property:level 1,1,1");
						t111[1] = CMRegisterType(level111, "type:level 1,1,1");
						
						/*----------*
						 | level112 |
						 *----------*/
						
						if (dbgFile) display(dbgFile, "\nlevel112\n");
						myRefCon112 = createRefConForMyEmbHandlers(ev112);
						setEmbeddedHandlersTrace(myRefCon112, traceHandlers, handlerDbgFile);
						level112 = CMOpenContainer(session, myRefCon112, "level112", 0);
						if (level112 == NULL) {
							display(stderr, "### embedded tests (reading) terminated: level112 == NULL\n");
							exit(EXIT_FAILURE);
						}
						p112[1] = CMRegisterProperty(level112, "property:level 1,1,2");
						t112[1] = CMRegisterType(level112, "type:level 1,1,2");
						if ((o112[1] = CMGetNextObjectWithProperty(level112, NULL, p112[1])) == NULL) {
							display(stderr, "### cannot find property in container (level112)\n");
							exit(EXIT_FAILURE);
						}
						ev1121 = CMUseValue(o112[1], p112[1], TestType(level112, "ev1121"));	

									/*-----------*
									 | level1121 |
									 *-----------*/
									 
									if (dbgFile) display(dbgFile, "\nlevel1121\n");
									myRefCon1121 = createRefConForMyEmbHandlers(ev1121);
									setEmbeddedHandlersTrace(myRefCon1121, traceHandlers, handlerDbgFile);
									level1121 = CMOpenContainer(session, myRefCon1121, "level1121", 0);
									if (level1121 == NULL) {
										display(stderr, "### embedded tests (reading) terminated: level1121 == NULL\n");
										exit(EXIT_FAILURE);
									}
									p1121[1] = CMRegisterProperty(level1121, "property:level 1,1,2,1");
									t1121[1] = CMRegisterType(level1121, "type:level 1,1,2,1");

				/*---------*
				 | level12 |
				 *---------*/

				if (dbgFile) display(dbgFile, "\nlevel12\n");
				myRefCon12 = createRefConForMyEmbHandlers(ev12);
				setEmbeddedHandlersTrace(myRefCon12, traceHandlers, handlerDbgFile);
				level12 = CMOpenContainer(session, myRefCon12, "level12", 0);
				if (level12 == NULL) {
					display(stderr, "### embedded tests (reading) terminated: level12 == NULL\n");
					exit(EXIT_FAILURE);
				}
				p12[1] = CMRegisterProperty(level12, "property:level 1,2");
				t12[1] = CMRegisterType(level12, "type:level 1,2");
				
	p1[3] = CMRegisterProperty(level1, "level 1a: data");
	o1[3] = CMGetNextObjectWithProperty(level1, NULL, p1[3]);
	v1[3] = CMUseValue(o1[3], p1[3], t1[1]);
	
	p1[4] = CMRegisterProperty(level1, "level 1b: data");
	o1[4] = CMGetNextObjectWithProperty(level1, NULL, p1[4]);
	v1[4] = CMUseValue(o1[4], p1[4], t1[1]);
	
	p11[3] = CMRegisterProperty(level11, "level 11: data");
	o11[3] = CMGetNextObjectWithProperty(level11, NULL, p11[3]);
	v11[3] = CMUseValue(o11[3], p11[3], t11[1]);
	
	p111[3] = CMRegisterProperty(level111, "level 111: data");
	o111[3] = CMGetNextObjectWithProperty(level111, NULL, p111[3]);
	v111[3] = CMUseValue(o111[3], p111[3], t111[1]);
	
	p112[3] = CMRegisterProperty(level112, "level 112: data");
	o112[3] = CMGetNextObjectWithProperty(level112, NULL, p112[3]);
	v112[3] = CMUseValue(o112[3], p112[3], t112[1]);
	
	p1121[3] = CMRegisterProperty(level1121, "level 1121: data");
	o1121[3] = CMGetNextObjectWithProperty(level1121, NULL, p1121[3]);
	v1121[3] = CMUseValue(o1121[3], p1121[3], t1121[1]);
	
	p12[3] = CMRegisterProperty(level12, "level 12: data");
	o12[3] = CMGetNextObjectWithProperty(level12, NULL, p12[3]);
	v12[3] = CMUseValue(o12[3], p12[3], t12[1]);

readEmbedded:
	
	amountRead = CMReadValueData(v1[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v1[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v1[3] = level1a: 1234567890ABCDEFGHIJ1234567890: level1a [48]");
	
	amountRead = CMReadValueData(v1[4], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v1[4] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v1[4] = level1b: ABCDEFGHIJ1234567890ABCDEFGHIJ: level1b [48]");
	
	amountRead = CMReadValueData(v11[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v11[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v11[3] = level11: 1234567890ABCDEFGHIJ1234567890: level11 [48]");
	
	amountRead = CMReadValueData(v111[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v111[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v111[3] = level111: ABCDEFGHIJ1234567890ABCDEFGHIJ: level111 [50]");
	
	amountRead = CMReadValueData(v112[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v112[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v112[3] = level112: ABCDEFGHIJ1234567890ABCDEFGHIJ: level112 [50]");
	
	amountRead = CMReadValueData(v1121[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v1121[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v1121[3] = level1121: 1234567890ABCDEFGHIJ1234567890: level1121 [52]");
	
	amountRead = CMReadValueData(v12[3], (CMPtr)buffer, 0, 256);
	*(buffer+amountRead) = 0;
	sprintf(whatWeGot, "    v12[3] = %s [%ld]", buffer, amountRead);
	checkIt(whatWeGot, "    v12[3] = level12: 1234567890ABCDEFGHIJ1234567890: level12 [48]");
	
	if (dbgFile && !fullEmbedClose) {
		display(dbgFile, "level12\n");
		CMDumpTOCStructures(level12, dbgFile);
		CMCloseContainer(level12);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level1121\n");
		CMDumpTOCStructures(level1121, dbgFile);
		CMCloseContainer(level1121);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level112\n");
		CMDumpTOCStructures(level112, dbgFile);
		CMCloseContainer(level112);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level111\n");
		CMDumpTOCStructures(level111, dbgFile);
		CMCloseContainer(level111);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level11\n");
		CMDumpTOCStructures(level11, dbgFile);
		CMCloseContainer(level11);
		display(dbgFile, "################################################\n");
		display(dbgFile, "level1\n");
		CMDumpTOCStructures(level1, dbgFile);
		CMCloseContainer(level1);
		display(dbgFile, "################################################\n");
	} else
		CMCloseContainer(level1);	
}


/*------*
 | main |
 *------*/

void CM_C main(int argc, char *argv[])
{
	#if THINK_C || THINK_CPLUS
	console_options.nrows = 70;
	console_options.ncols = 93;
	argc = ccommand(&argv);
	#endif
	
	processOptions(argc, argv);
	
	if (*filename == 0) strcpy(filename, "TestC"        );
	strcpy(origFilename, filename);
	
	session = CMStartSession(sessionRoutinesMetahandler, NULL);
	CMDebugging(session, 256, dbgFile, 1);

	if (embedTestOnly) 
		doEmbeddedTests();
	else if (basicTestOnly)
		doBasicTests(true, filename);
	else if (convTestOnly)
		doConvertingTests();
	else if (refsTestOnly)
		doReferenceTests();
	else {
		doBasicTests(true, filename);
		doConvertingTests();
		doEmbeddedTests();
		doReferenceTests();
	}
	
	CMEndSession(session, false);
	
	if (failures)
		display(stderr, "\n### successful tests passed: %ld\n"
											"    failed tests:            %ld\n\n", successes, failures);
	else
		display(stderr, "\n### All tests passed!  Ship it!\n\n");

	exit(EXIT_SUCCESS);
}

														  CM_END_CFUNCTIONS

